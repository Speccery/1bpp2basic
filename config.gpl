* config.gpl
* Configurator for GROMMY2
* At this point this is just a demo how to render the generated screen.gpl
* EP 2023-11-26
*
* Compile the GPL code to binary with:
* xga99.py --aorg 0x6000 config.gpl -L config.lst -o config.bin
* output file is config.bin, since the filename ends with g it is treated
* by an emulator such as js99er.net as a GROM file.
*
* This file includes the screen.gpl file at the very end.
*

LALIGN    EQU >02              Left alignment of text
LALIGN2   EQU >03
LAYOUTVER EQU 5         Row for Version number
LAYOUTBAN EQU 8        Row for selected bank display
VEROFS    EQU 32*LAYOUTVER
VALIDIND  EQU VEROFS-29         ; Indicator for valid command

* A few variables for the grommy2 config to use.
* I am not sure if these are free to use, but I will try :) 
XREG    EQU >832C   ; ** Program text or token pointer (in BASIC?)
YREG    EQU >832E   ; ** Pointer to line number tale (in BASIC)
ZREG    EQU >8330   ; ** Start of line number table pointer (in BASIC)
; >8332 .. 8337 seem to contain pointers also used by BASIC not GPL

* Grommy2 command buffer in scratchpad
GCMDBYTE EQU >8340
GCMDP2   EQU >8342
GCMDP3   EQU >8343
GCMDP4   EQU >8344
GCMDP5   EQU >8345
GCMDP6   EQU >8346
GCMDP7   EQU >8347

BANK    EQU >8350           Active bank
SHADOW  EQU >8351           Shadow enable / disable
PAD0    EQU >835C
PAD1    EQU >835D
PAD2    EQU >835E
PAD3    EQU >835F
PAD4    EQU >8360
PAD5    EQU >8361
INDEX   EQU PAD5
DUMPA   EQU >8362           ; GROM Dump address
VRAMP   EQU >8340           ; VRAM ptr overlays GCMDBYTE

DSP     EQU >8372           ; GPL data stack pointer 
SCANKEY EQU >8375   
VDPTIMER EQU >8379          ; Incremented by VDP interrupts
* Hardware interface address
HWIF     EQU >5FF0

HEXBASECH EQU >E0         ; Base character for hex display
ALIVECH   EQU >DF         ; Placed in top right corner, show we are alive


G6000  DATA >AA01             standard header  version 1
       DATA >0000             # of programs 0
       DATA >0000             no power up
       DATA G6010             program
       DATA >0000             DSRs
       DATA >0000             subprograms
       DATA >0000
       DATA >0000

G6010  DATA >0000         * No next program
       DATA GPROG
       STRI 'GROMMY2 CONFIG'

GVREGS 
    BYTE  >E0              VDP registers values: standard mode
    BYTE  >00              screen image at >0000
    BYTE  >0E              color table at >0380
    BYTE  >01              char patterns at >0800
    BYTE  >06              sprite attributes at >0300
    BYTE  >00              sprite patterns at >0000
    BYTE  >F5              text/screen colors: white / light blue                

GPROG  
    CLR   @>8374
    DST   >0900,@>834A     load upper case chars 32->
    CALL  G@>0018
* Setup roughly as with mini memory          
    MOVE >0007,G@GVREGS,#>01    Set VDP Regs
    CLR   V@>0800          clear charpats 0-31
    MOVE  >00FF,V@>0800,V@>0801

    ST    >7E,@>8373       init subroutine stack
    DCLR  @>8322           clear error code
    DCLR  @>8348           clear flags      

    DCLR   @DUMPA
    CLR    @BANK           Actually init from grommy2 
    CLR    @SHADOW         Actually init from grommy2 

    DCLR   @XREG
    DCLR   @YREG
    DCLR   @ZREG

    CALL G@GVDPSETUP  

    CALL G@G_SCR1       ; Setup the screen which was automatically generated
* Setup additional chars E0..EF as numbers 0..9 and A..F
* 0x980 = hex(0x800+ord('0')*8)
* 0xa08 = hex(0x800+ord('A')*8)
* 0xf00 = hex(0x800+0xe0*8)
* 0xf50 = hex(0x800+0xea*8)
CHSRC1 EQU >800+(8*'0')
CHSRC2 EQU >800+(8*'A')
CHOFS1 EQU >800+(8*HEXBASECH)
CHOFS2 EQU >800+(8*(HEXBASECH+10))
    MOVE 10*8,V@CHSRC1,V@CHOFS1  * 10 number patterns
    MOVE  6*8,V@CHSRC2,V@CHOFS2
* Set the colors for these characters.
    ST   >A5,V@>39C    
    ST   >A5,V@>39D
* Make the fonts "bold"
    DST  >F00,@VRAMP
!   ST   V@0(@VRAMP),@PAD0
    SRL  1,@PAD0
    OR   V@0(@VRAMP),@PAD0
    ST  @PAD0,V@0(@VRAMP)
    DINC @VRAMP
    DCEQ >F80,@VRAMP
    BR   -!
* Copy the fonts to make inverse duplicates
    MOVE >80,V@>F00,V@>F80
    ST   >5A,V@>39E    
    ST   >5A,V@>39F

SCREEN1:
* Use the FMT token to add some strings on the screen    
    FMT
    COL LALIGN
    ROW LAYOUTVER
    HTEX 'VERSION 0.0.00 BANK 0 SHADOW 0'
    ROW+ >01
    COL LALIGN
    HTEX 'SELECT GROM BANK FOR READS'
    ROW+ >01
    COL LALIGN2
    HTEX '0 SYSTEM BANK'
    ROW+ >01
    COL LALIGN2
    HTEX '1 USER BANK 1'
    ROW+ >01
    COL LALIGN2
    HTEX '2 USER BANK 2'
    ROW+ >01
    COL LALIGN2
    HTEX '3 GRAM BANK'

    ROW+ >02
    COL LALIGN
    HTEX 'SHADOW RAM'
    ROW+ >01
    COL LALIGN2
    HTEX '4 ENABLE     5 DISABLE'

    ROW+ >02
    COL LALIGN
    HTEX 'FLASH GRAM TO USER BANK'
    ROW+ >01
    COL LALIGN2
    HTEX '6 BANK 1     7 BANK 2'

    ROW+ >02
    COL LALIGN
    HTEX 'COPY ROM BANK TO GRAM'
    ROW+ >01
    COL LALIGN2
    HTEX 'A COPY FROM SYSTEM BANK'
    ROW+ >01
    COL LALIGN2
    HTEX 'B COPY FROM USER BANK 1'
    ROW+ >01
    COL LALIGN2
    HTEX 'C COPY FROM USER BANK 2'

    ROW+ >01
    COL LALIGN
    HTEX '9 MORE...'

    FEND

* Pattern address of character ALIVECH
PATADR EQU >0800+(8*ALIVECH)      
* Test a couple of chars 
*    MOVE 64,G@DENSE_FONT,V@PATADR-64
*    ST >F7,V@0
*    ST >F8,V@1
*    ST >F9,V@2
*    ST >FA,V@3
*    ST >FB,V@4
*    ST >FC,V@5
*    ST >FD,V@6
*    ST >FE,V@7

    CALL  SHOW_VERSION      ; Get version, bank, shadow info
    B     GUPDATE           ; update screen

GWAIT
    SCAN
    BS    GOTKEY
* We did not get a key. Animate something.
    ST    ALIVECH,V@>001F      Write char FF to top right corner
    INC   V@PATADR
    B    G@GWAIT          wait for the user to press a key


GOTKEY:
    ST    @SCANKEY,V@VEROFS-30  ; Make key visible.
    CALL  CLEARVALID
    CGT   '0'-1,@SCANKEY       greater than >= 0
    BR    GG01              no skip forward
    CGT   '9',@SCANKEY        Key greater than '9'?
    BS    CHECK_ABC             ; Yes: skip forward
    SUB   '0',@SCANKEY
    CASE  @SCANKEY
    BR    KEY0
    BR    KEY1
    BR    KEY2
    BR    KEY3
    BR    KEY4
    BR    KEY5
    BR    KEY6
    BR    KEY7
    BR    KEY8
    BR    KEY9
CHECK_ABC 
; Commands A,B and C
    CGT   'A'-1,@SCANKEY
    BR    GG01
    CGT   'C',@SCANKEY
    BS    GG01
    SUB   'A',@SCANKEY
    CASE  @SCANKEY
    BR    KEYA
    BR    KEYB
    BR    KEYC

KEY4:   
    ST  1,@SHADOW
SHADOWSET
    ST  @SHADOW,@GCMDP2    ; Set parameter 2
    ST  3,@GCMDBYTE         ; Command 3 shadow enable/disable
    BR  ISSUECMD
KEY5:   
    CLR @SHADOW
    BR  SHADOWSET
KEY0
KEY1
KEY2
    ST   @SCANKEY,@BANK
    ST   @SCANKEY,@GCMDP2    ; Set parameter 2
BANKSEL
    ST   1,@GCMDBYTE         ; Command 1 select bank for reads
    BR  ISSUECMD
KEY3
    ST   @SCANKEY,@BANK
    ST   8,@GCMDP2           ; GRAM bank is 8
    BR   BANKSEL

KEY6:                       ; Flash GRAM to user bank 1
    ST   >01,@GCMDP2        ; User bank 1
GRAM2FLASH    
    ST   >3F,@GCMDP3        ; Bit mask: flash entire bank
    ST   4,@GCMDBYTE
    BR  ISSUECMD
KEY7:                       ; Flash GRAM to user bank 2
    ST   >02,@GCMDP2        ; User bank 2
    BR   GRAM2FLASH
KEY8
    ST    '*',V@VALIDIND    ; Command valid indicator
    CALL  SHOW_VERSION
    BR    GWAIT
KEY9: 
    B   DUMPSCREEN

KEYA:                       ; Copy bank 0 to GRAM
    ST    0,@GCMDP2
COPY2GRAM:
    ST    '*',V@VALIDIND    ; Command valid indicator   
    ST    2,@GCMDBYTE
    BR    ISSUECMD
KEYB:
    ST    1,@GCMDP2
    BR    COPY2GRAM
KEYC:
    ST    2,@GCMDP2
    BR    COPY2GRAM

ISSUECMD1:                  ; Clear last 4 parameter bytes
    DCLR  @GCMDBYTE+4
    DCLR  @GCMDBYTE+6
ISSUECMD:
    MOVE  8,G@GROMMY_DAT+8,@GCMDBYTE+8  ; Unlock string
    ST    '*',V@VALIDIND    ; Command valid indicator
    CALL  GSENDCMD          ; Send command to HW

GG01:    
    CEQ   >0F,@SCANKEY       is it Fctn-9?
    BR    G@GCONT2         no: GCONT2
    EXIT                   yes: reset the TI-99/4A

GCONT2
* Update screen to reflect current status
GUPDATE 
* Status of Shadow RAM enable/disable
    ST  '0',@PAD0
    ADD @SHADOW,@PAD0
    ST  @PAD0,V@VEROFS+>1F        Write to VRAM
* Status of selected bank
    ST  '0',@PAD0
    ADD @BANK,@PAD0
    ST  @PAD0,V@VEROFS+>16  ; Write to VRAM


* Start update GROM read bank. First erase bank markings.
BANKOFS EQU (32*LAYOUTBAN)+4
    ST ' ',V@BANKOFS
    ST ' ',V@BANKOFS+>20
    ST ' ',V@BANKOFS+>40
    ST ' ',V@BANKOFS+>60
    DCLR @PAD0
    ST   @BANK,@PAD3        Copy to low byte the bank #
    DSLL 5,@PAD2          Shift by 5 to get 32 chars per line
    ST  '*',V@BANKOFS(@PAD2)   Screen offset 102
* End update GROM read bank.    
    B   G@GWAIT

*----------------------------------------
* Second screen with a few features.
*----------------------------------------
DUMPSCREEN:
    ST   ' ',V@VEROFS
    MOVE 768-VEROFS-1,V@VEROFS,V@VEROFS+1   ; Clear screen bottom
    FMT
    COL LALIGN
    ROW LAYOUTVER
    HTEX '1 DEC 2 INC DUMP ADDR 3 RET'
    ROW+ >01
    COL LALIGN
    HTEX '4 FILL GRAM WITH FF'
    ROW+ >01
    COL LALIGN
    HTEX '5 COPY 24K GROM 8000 TO GRAM'
    ROW+ >01
    COL LALIGN
    HTEX '6 ARM EXECUTE 0000'
    ROW+ >01
    COL LALIGN
    HTEX '7 ARM EXECUTE 4000'
    ROW+ >01
    COL LALIGN
    HTEX '0 BURN FIRMWARE FROM GRAM'
    ROW+ >02
    COL LALIGN
    HTEX 'GROM DUMPER'
    FEND

    MOVE EBIN2HEX-BIN2HEX,G@BIN2HEX,@>8300 ; Move assembly code in place

* ; test characters on last line 
*     ST  HEXBASECH,@PAD0
*     DST 32*23,@VRAMP          * Beginning of last row
* !   ST  @PAD0,V@0(@VRAMP)
*     DINC @VRAMP
*     INC @PAD0
*     CZ  @PAD0 
*     BR  -!


; First test in units of frame count (VDPTIMER)
; Test runs for 4 frames.
;   GPL with original HEXOUT: 119 ticks
;   GPL call to GPL HEXOUT routine issuing XML >F0:  55 ticks
;   Replace GPL call with XML >F0: 47 ticks
;   All GPL with new hex characters, no gap between '9' and 'A': 87 ticks
;     This also handles two characers at a time. But still slow.
    .defm DOHEXOUT
    XML >F0
    ;;;; CALL  HEXOUT1
    ;;; CALL  HEXOUT2
    .endm

**    B  SKIPBENCH
; Run benchmark
    ST    4,@XREG               ; Loop counter
    ST    @VDPTIMER,@XREG+1     ; Read timer
!   CALL  G@DODUMP
    DADD  8,@DUMPA
    DEC   @XREG
    CZ    @XREG
    BR   -!
    ST    @VDPTIMER,@XREG       ; Read timer
    DSUB  4*10,@DUMPA
** SKIPBENCH:

MAKEDUMP:
    DST  @YREG,@DUMPA
    CALL G@DODUMP
    CALL  CLEARVALID
; Wait for keypress
KW1:    
    SCAN
    BS    DGOTKEY
    INC   V@PATADR
    B     KW1
DGOTKEY:
    ST    @SCANKEY,V@VEROFS-30  ; Make key visible.
    CGT   'X'-1,@SCANKEY    ; Key >= 'X'
    BS    XYZ               ; Yes: go to XYZ
    CGT   '0'-1,@SCANKEY
    BR    KW1               ; Key less than zero -> loop
    CGT   '7',@SCANKEY      ; Key over '7' -> loop
    BS    KW1
    SUB   '0',@SCANKEY
    CASE  @SCANKEY          
    BR    DKEY0
    BR    DKEY1
    BR    DKEY2
    BR    DKEY3
    BR    DKEY4 
    BR    DKEY5
    BR    DKEY6
    BR    DKEY7

DODUMP:
    DST   VEROFS+224,@VRAMP
    CLR   @PAD2             ; Row counter
    ST    '*',V@VALIDIND
DUMP2:    
    ST    ' ',V@>FFFF(VRAMP)    ; setup VRAM address in case assembly used
    ST    @DUMPA,@PAD0      ; Hi byte off address
    .DOHEXOUT
    DADD  2,@VRAMP
    ST    @DUMPA+1,@PAD0    ; Lo byte off address
    .DOHEXOUT
    ST    ':',V@2(@VRAMP)
    DADD  3,@VRAMP
    CLR   @PAD1             ; column counter
; Dump 8 bytes from from 16 bit ptr  DUMPA
DUMP1:
    MOVE  1,G@0(@DUMPA),@PAD0    ; Read from GROM pointed to by DUMPA
    .DOHEXOUT
    ST    ' ',V@2(@VRAMP)
    DADD  3,@VRAMP
    DINC  @DUMPA
    INC   @PAD1
    CEQ   8,@PAD1           ; 8 columns - are we done?
    BR    DUMP1             ; No: jump to dump1 
; Advance VRAM pointer, we add and mask to bring pointer to beginning
; of next line.
    DADD  >1F,@VRAMP
    DAND  >0FE0,@VRAMP
    INC   @PAD2             ; inc Row
    CEQ   8,@PAD2           ; Done with 8 rows?
    BR    DUMP2             ; No: jump to dump2
    DSUB  8*8,@DUMPA           ; Undo the incs in the loop above
    RTN    

; Check if we have button X Y Z pressed
XYZ:  
    CGT   'Z',@SCANKEY    ; Above Z?
    BS    KW1             ; Yes: KW1
; Ok now we need to ask the user for a value and store it to X, Y or Z register. 
; Show the current value of the variable after character code
    DST   VEROFS-29,@VRAMP ; Location in VRAM
    ST    @SCANKEY,@PAD3 
    SUB   'X',@PAD3       ; Now pad is 0,1,2 for X,Y,Z
    SLL   1,@PAD3         ; Multiply by 2
    CLR   @PAD2           ; clear high byte
    DADD  XREG,@PAD2       ; Add address of XREG, now PAD1:PAD2 is a pointer to value

    ST    @0(@PAD2),@PAD0  ; Hi byte of reg
    .DOHEXOUT
    DADD  2,@VRAMP
    ST    @1(@PAD2),@PAD0  ; Lo byte of reg 
    .DOHEXOUT
    DSUB  2,@VRAMP          ; Point to beginning of hex digits
    ST    4,@PAD4           ; 4 digits to edit, VRAMP points to them
    CALL  EDITHEX           ; go and edit them
; YREG is used as dump addres. If it changed, refresh screen.
    DCEQ  @YREG,@DUMPA
    BR    MAKEDUMP    
    B     G@KW1



ASKCONFIRM:
; Ask for confirmation. Clear a few rows to clarify
    ST   ' ',V@VEROFS
    MOVE 768-VEROFS-1,V@VEROFS,V@VEROFS+1   ; Clear screen bottom
    FMT
    COL LALIGN
    ROW LAYOUTVER
    HTEX '!!PRESS 1 TO CONFIRM!!'
    FEND
WAIT0:
    SCAN
    BR    WAIT0
    RTN

DKEY1:
    DSUB  64,@YREG
    B     MAKEDUMP
DKEY2:
    DADD  64,@YREG
    B     MAKEDUMP
DKEY3:
    ST   ' ',V@VEROFS
    MOVE 768-VEROFS-1,V@VEROFS,V@VEROFS+1   ; Clear screen bottom
    B     SCREEN1
DKEY0:      ; Burn to Flash
    CALL  G@ASKCONFIRM
    CEQ   '1',@SCANKEY       is the key one?
    BR    G@DUMPSCREEN       no: DUMPSCREEN
; Yes, continue to Flash the MCU
    BACK  >F3              screen colors: white on some other color
    ST    'F',V@VALIDIND    ; Command valid indicator   
    ST    6,@GCMDBYTE
    DST   >1234,@GCMDBYTE+2
    DCLR  @GCMDBYTE+4
    DCLR  @GCMDBYTE+6
    CALL  ISSUECMD
; We probably do not return from this call... GROMMY might be in a funny state
    B     G@MAKEDUMP

DKEY4:      ; Command to fill GRAM with >FF, all 24K
    DST   >FFFF,@PAD2   ; Fill value, 2 bytes
    ST    '*',V@VALIDIND    ; Command valid indicator   
    MOVE  >1,@PAD2,G@>0
    MOVE  >5FFF,G@>0,G@>1
    CALL  CLEARVALID
    B     MAKEDUMP

DKEY5:
    ST    '*',V@VALIDIND    ; Command valid indicator   
    MOVE >2000,G@>8000,G@>0000
    MOVE >2000,G@>A000,G@>2000
    MOVE >2000,G@>C000,G@>4000
    CALL  CLEARVALID
    B     MAKEDUMP

DKEY6:      ; ARM execute 0000
    DST   >0100,@GCMDBYTE+2   ; thumb bit high
DKEY6ASK:
    CALL  G@ASKCONFIRM
    CEQ   '1',@SCANKEY       is the key one?
    BR    G@DUMPSCREEN       no: DUMPSCREEN
    ST    'F',V@VALIDIND    ; Command valid indicator   
    ST    7,@GCMDBYTE
    DCLR  @GCMDBYTE+4
    DCLR  @GCMDBYTE+6
    CALL  ISSUECMD
; We probably do not return from this call... GROMMY might be in a funny state
    BR    MAKEDUMP

DKEY7:
    DST   >0140,@GCMDBYTE+2  ; ARM has different byte order
    BR    DKEY6ASK

*----------------------------------------
CLEARVALID:
    ST    ' ',V@VALIDIND
    ST    ' ',V@VALIDIND+1
    ST    ' ',V@VALIDIND+2
    ST    ' ',V@VALIDIND+3
    RTN

*----------------------------------------
* Edit HEX
* Number already dsiplayed with E0..EF or F0..FF.
* Parameters:
*   VRAMP points to the screen area.
*   PAD2:PAD3 points to the value.
*   PAD4 number of digits to edit. Must be even.
*----------------------------------------
EDITHEX:
    CLR  @INDEX   ; current digit index
EWAIT:
    SCAN
    BS   EGOTKEY
; No key. Flash the cursor pointed at VRAMP by copying bit 4 of frame counter
; to the character code.
    ST   @VDPTIMER,@PAD0
    AND  >10,@PAD0
    ST   V@0(@VRAMP),@PAD1
    AND  >EF,@PAD1
    OR   @PAD1,@PAD0
    ST  @PAD0,V@0(@VRAMP)
    INC   V@PATADR
    B    EWAIT

EGOTKEY:    ; We received a key. If it is '0' - '9' or 'A'-'F' it is a hex digit, thus edit.
    CGT   '0'-1,@SCANKEY       ; greater than >= 0
    BR    ENODIGIT             ; No -> ENODIGIT
    CGT   '9',@SCANKEY         ; Key greater than '9'?
    BS    CHECKAF
    SUB   '0',@SCANKEY         ; Here we have '0'-'9' make it 0-9
GOTDIGIT:
    ADD   HEXBASECH,@SCANKEY
    ST    @SCANKEY,V@0(@VRAMP)  ; Store digit into VRAM.
    DINC  @VRAMP
    INC   @INDEX
    CEQ   @INDEX,@PAD4          ; Index=number of digitss?
    BR    EWAIT                 ; No: get back to waiting next key
    CALL  BACK2BEGIN
    B     EWAIT                 ; Wait for next keypress

BACK2BEGIN:
    AND   >EF,V@0(VRAMP)        ; Yes: make sure no cursor show here.
    SUB   @INDEX,@VRAMP+1       ; Yes: Reset VRAMP back to beginning of number (BUGBUG: carry not handled!)
    CLR   @INDEX                ; Reset index
    RTN

CHECKAF:                        ; Check if we have 'A'..'F'
    CGT   'A'-1,@SCANKEY        ; >= 'A' ?
    BR    ENODIGIT              ; no: -> ENODIGIT
    CGT   'F',@SCANKEY          ; >= 'F' ?
    BS    ENODIGIT              ; Yes: -> ENODIGIT
    SUB   'A'-10,@SCANKEY       ; Make 'A' into 10
    B     GOTDIGIT              ; Display etc.

ENODIGIT:                       ; Here we do not have digit 0-9, A-F
    CEQ    13,@SCANKEY          ; Is it enter?
    BR     EWAIT                ; No: get next key
; Here we have the digits in VRAM. Decode the number.
    CALL   BACK2BEGIN           ; Reset VRAMP to beginning of number
!   ST     V@0(@VRAMP),@PAD0    ; Get first digit
    AND    >0F,@PAD0            ; Low 4 bits are the hex digit
    SLL    4,@PAD0
    ST     V@1(VRAMP),@PAD1     ; Get second digit
    AND    >0F,@PAD1
    OR     @PAD1,@PAD0          ; Now PAD0 has the byte.
    ST     @PAD0,@0(@PAD2)      ; Store byte
    INCT   @INDEX
    DINC   @PAD2
    DINCT  @VRAMP
    CEQ    @INDEX,@PAD4         ; Are we at the end, INDEX==COUNT?
    BR     -!                   ; No, continue
    SUB    @INDEX,@PAD3         ; Reset PAD2:PAD3 pointer (BUGBUG no carry)
    CALL   BACK2BEGIN           ; Reset VRAMP
    RTN                         ; Done


*----------------------------------------
* Display in HEX the byte in PAD0
*----------------------------------------
HEXOUT:
  XML >F0       ; Jump via >8300
  RTN

HEXOUT1:
    ST   @PAD0,@PAD4
    SRL   >04,@PAD4       isolate first nibble
    CGT   >09,@PAD4       greater than 9?
    BS    HEX1            yes
    ADD   >30,@PAD4       no: make it char 0-9
    BR    HEX2
HEX1: ADD   >37,@PAD4      yes: make it char A-F
HEX2: 
; Output first hex digit (most significant digit)
    ST    @PAD4,V@0(@VRAMP)
; Work on 2nd digit    
    ST    @PAD0,@PAD4     copy number
    AND   >0F,@PAD4       isolate second nibble
    CGT   >09,@PAD4       greater than 9?
    BS    HEX3          yes
    ADD   >30,@PAD4       no: make it char 0-9
    BR    HEX4
HEX3  ADD   >37,@PAD4       yes: make it char A-F
HEX4:
; Output 2nd hex digit (least significant digit)
    ST    @PAD4,V@1(@VRAMP)
    RTN

* Use the new hex characters which do not have a gap between 9 and A
HEXOUT2:
    ST   @PAD0,@PAD4
    ST   @PAD0,@PAD5
    SRL  >04,@PAD4       isolate first nibble
    AND  >0F,@PAD5 
TWINHEXBC EQU   (HEXBASECH * 256) + HEXBASECH  
    DADD TWINHEXBC,@PAD4
    DST  @PAD4,V@0(VRAMP)
    RTNC

*----------------------------------------
* Read grommy2 version, update on screen.
* Also read and set bank & shadow values.
*----------------------------------------
SHOW_VERSION
    CALL G@GINITCMD
    CALL G@GSENDCMD
* Check result of command - did we get OK?
    MOVE 2,G@HWIF,@PAD0
    DCEQ >4F4B,@PAD0        ; did we get OK?
    BS   VER_OK             ; Yes: go to VER_OK
** No grommy2 detected. Put in dummy data.    
    DCLR @PAD2              ; Major and minor zero
    ST   99,@PAD4           ; Build 99
    CLR  @SHADOW
    CLR  @BANK
    BR   VER1
VER_OK:     ; grommy responded, read data
* Copy values from GROM IF to pad
    MOVE 3,G@HWIF+8,@PAD2
* Get active bank from grommy2
    MOVE 1,G@HWIF+3,@BANK
    AND  >0F,@BANK
    CEQ  8,@BANK            ; Is GRAM bank 8 selected?
    BR   NOGRAM1            ; No, we're good
    ST   3,@BANK            ; yes, convert to 3 here
NOGRAM1:    
* Get RAM shadow from grommy2
    MOVE 1,G@HWIF+4,@SHADOW
VER1:
* Show major version in p2
    ST  '0',@PAD0
    ADD @PAD2,@PAD0
    ST  @PAD0,V@VEROFS+>A        Write to VRAM
* Show minor version in p3
    ST  '0',@PAD0
    ADD @PAD3,@PAD0
    ST  @PAD0,V@VEROFS+>C        Write to VRAM
* Show build version in p4. The build is two digits from 0 to 99
    CLR  @PAD0              Zero fill as the value to divide is 16 bits§
    ST   @PAD4,@PAD1      
    DIV  10,@PAD0           Quotiotent in PAD0, remainder PAD1
    ADD  '0',@PAD0
    ST   @PAD0,V@VEROFS+>E      Write to VRAM
    ADD  '0',@PAD1          Remainder
    ST   @PAD1,V@VEROFS+>F      Write to VRAM
    RTN


*----------------------------------------
* Init command buffer in pad
*----------------------------------------
GINITCMD
       MOVE  >0010,G@GROMMY_DAT,@GCMDBYTE    Copy command template from GROM
       RTN

*----------------------------------------
* Send command to grommy2
*----------------------------------------
GSENDCMD
       ST   @GCMDBYTE,@GCMDBYTE+1        Setup the complement of command byte
       XOR   >FF,@GCMDBYTE+1             
       MOVE  >0010,@GCMDBYTE,G@HWIF      Send command to grommy2
       RTN


GROMMY_DAT 
       DATA   >00FF,>003F,>0000,>0000
       TEXT 'EPGROMMY'


DENSE_FONT ; Define character cells wihtin 4x8 cell
; Numnbers 0 and 1
        BYTE >22    
        BYTE >56
        BYTE >52
        BYTE >52
        BYTE >52
        BYTE >52
        BYTE >27    
        BYTE >00   
; Define a cell with 2 and 3                    
        BYTE >26    
        BYTE >51
        BYTE >11
        BYTE >26
        BYTE >41
        BYTE >41
        BYTE >76    
        BYTE >00   
; Define a cell with 4 and 5
        BYTE >17    
        BYTE >34
        BYTE >54
        BYTE >76
        BYTE >11
        BYTE >11
        BYTE >16    
        BYTE >00   
; Define a cell with 6 and 7
        BYTE >37    
        BYTE >41
        BYTE >62
        BYTE >52
        BYTE >52
        BYTE >52
        BYTE >22    
        BYTE >00   
; Define a cell with 8 and 9
        BYTE >22    
        BYTE >55
        BYTE >55
        BYTE >23
        BYTE >51
        BYTE >51
        BYTE >26    
        BYTE >00   
; Define a cell with A and B
        BYTE >26    
        BYTE >55
        BYTE >55
        BYTE >76
        BYTE >55
        BYTE >55
        BYTE >56    
        BYTE >00   
; Define a cell with C and D
        BYTE >36    
        BYTE >45
        BYTE >45
        BYTE >45
        BYTE >45
        BYTE >45
        BYTE >36    
        BYTE >00   
; Define a cell with E and F
        BYTE >77    
        BYTE >44
        BYTE >44
        BYTE >66
        BYTE >44
        BYTE >44
        BYTE >74    
        BYTE >00   

* Test code copied from Mini Memory
       MOVE  >0010,G@GROMMY_DAT,@GCMDBYTE    place parameter string in PAD
       ST    @>839A,@>8340                Copy command byte
       ST    @>839A,@>8341                The second byte is its complement
       XOR   >FF,@>8341
       ST    @>839B,@>8342                Copy p2.
       MOVE  >0010,@>8340,G@HWIF         Copy from PAD @8340 to GRAM @5FF0. Does this work? Yes!
       RTN

* BIN2HEX assembly routine. Compiled to run from 8302.
* First item is a vector, so this is good for XML >F0.
BIN2HEX:
    DATA >8302
    DATA >D060, >835C    
    DATA >0941
    DATA >0221, >E000
    DATA >DBC1, >FFFE
    DATA >D060, >835C    
    DATA >0241, >0F00
    DATA >0221, >E000
    DATA >DBC1, >FFFE
    DATA >045B
EBIN2HEX DATA >000 ; dummy

* 0010 8302 D060  34   MOVB @PAD0,R1
*      8304 835C     
* 0011 8306 0941  56   SRL  R1,4
* 0012 8308 0221  22   AI   R1,256*HEXBASECH
*      830A E000     
* 0013 830C DBC1  38   MOVB  R1,@>FFFE(R15)  write byte to VDP
*      830E FFFE     
* 0014 8310 D060  34   MOVB @PAD0,R1
*      8312 835C     
* 0015 8314 0241  22   ANDI R1,>0F00
*      8316 0F00     
* 0016 8318 0221  22   AI   R1,256*HEXBASECH
*      831A E000     
* 0017 831C DBC1  38   MOVB  R1,@>FFFE(R15)  write byte to VDP
*      831E FFFE     
* 0018 8320 045B  20   RT




* Old version
*  DATA >8302    * Vector to 8302
*  DATA >C08B, >D060, >835C, >0941, >06A0
*  DATA >8318   * BL destination address
*  DATA >D060, >835C, >0241, >0F00, >C2C2
*  DATA >0221, >3000, >0281, >3A00, >1A02
*  DATA >0221, >0700, >DBC1, >FFFE, >045B
* 0005 0000 C08B  18   MOV R11,R2
* 0006 0002 D060  34   MOVB @PAD0,R1
*      0004 835C     
* 0007 0006 0941  56   SRL  R1,4
* 0008 0008 06A0  32   BL   @!
*      000A 8318    
* 0009 000C D060  34   MOVB @PAD0,R1
*      000E 835C     
* 0010 0010 0241  22   ANDI R1,>0F00
*      0012 0F00     
* 0011 0014 C2C2  18   MOV R2,R11
* 0012               !:
* 0013 0016 0221  22   AI   R1,'0'*256
*      0018 3000     
* 0014 001A 0281  22   CI   R1,('9'+1)*>100
*      001C 3A00     
* 0015 001E 1A02  14   JL   !
* 0016 0020 0221  22   AI   R1,>700
*      0022 0700     
* 0017               !
* 0018 0024 DBC1  38   MOVB  R1,@>FFFE(R15)  write byte to VDP
*      0026 FFFE     
* 0019 0028 045B  20   RT


*----------------------------------------
* VDP setup for module
*----------------------------------------
GVDPSETUP  
    ST    >D0,V@>0300      no sprites
    ST    >F5,V@>0380      init color table as white on blue for all chars
    MOVE  >001F,V@>0380,V@>0381
    ALL   >20              erase screen
    BACK  >F5              screen colors: white on light blue
    RTN

    COPY 'screen.gpl'
